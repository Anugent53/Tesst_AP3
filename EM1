import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

# define the nonlinear derivative function with parameters a and b
def nonlinear1(t, y, a, b):
    """
    Calculates the derivative value for the differential equation given in experiment R1, with parameters a and b.
    :param t: a float for the time variable
    :param y: a float for the dependent variable
    :param a: a float for the coefficient of y^3
    :param b: a float for the coefficient of sin(t)
    :return dydt a float for the derivative of the differential equation:
    """

    # Calculate the derivative explicitly with parameters a and b
    dydt = -a * y**3 + b * np.sin(t)

    # return the value
    return dydt

def main():
    """
    A main function used to ensure that the code is portable. By using if __name__ == '__main__': main() we can ensure
    that python will not execute the code when functions or methods in this module are imported, only if we run it
    directly. At this point, this structure isn't needed, but it's a good habit to get into.
    :return:
    """
    # define the initial variables
    y0 = np.array([0])  # initial state at t = 0
    t0 = 0  # initial time
    tf = 20  # final time
    n = 101  # Number of points at which output will be evaluated
    t = np.linspace(t0, tf, n)  # create a numpy array of n times linearly spaced between t0 and tf

    # Define arrays of parameters a and b
    a_values = [1] # Five different values for a
    b_values = [1]  # Five different values for b

    plt.figure(figsize=(10, 8))  # Adjust the figure size

    # Loop over all combinations of a and b values
    for a in a_values:
        for b in b_values:
            # Call the RK integrator and return the solution in the array "result"
            result = integrate.solve_ivp(fun=lambda t, y: nonlinear1(t, y, a, b),  # pass parameters to the function
                                         t_span=(t0, tf),  # Initial and final times
                                         y0=y0,  # Initial state
                                         method="RK45",  # Integration method
                                         t_eval=t)  # Time points for result to be reported

            # Read the solution and time from the array returned by Scipy
            y = result.y[0]

            # plot the solution with a label for a and b
            plt.plot(t, y, label=f'a={a}, b={b}')
    # Add labels and title
    plt.title("Solution of the Differential Equation")
    plt.xlabel("Time (s)")
    plt.ylabel("Position")
    plt.legend(loc="best")
    plt.grid(False)

    # Show the plot
    plt.show()

if __name__ == '__main__':
    main()
